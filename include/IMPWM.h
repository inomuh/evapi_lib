/*
 * IMPWM.h
 *
 *  Created on: Mar 19, 2015
 *      Author: makcakoca
 */

#ifndef INCLUDE_IMPWM_H_
#define INCLUDE_IMPWM_H_

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

class IMPWM
{

public:
	//! Default Constructor
	// PWM resolution (counts) 256, Duty Cycle 50% and PWM mode is 'PWMMODE'
	IMPWM();

	//! Constructor
	IMPWM(double d_Hz, unsigned int u_i_counts, double d_duty,  int i_m);

	//! Destructor
	~IMPWM();

	//! Frekans atar
	unsigned int SetFrequency(const double & c_d_hz);

	//! Counts deÄŸerini atar
	unsigned int SetCounts(const unsigned int & c_u_i_counts);

	//! PWM Cozunurlugunu atar.
	unsigned int SetDutyCycle(const double &c_d_duty, int i_pwm_no);

	// Sets Duty Cycle as a Percentage (Fast)
	unsigned int SetDutyCycleCount(const unsigned int &c_u_i_counts, int i_pwm_no);
		// Sets Duty Cycle as a count value (Fast) i.e. if counts is 1024
	// and 'duty' is set to 512, a 50% duty cycle is achieved

	unsigned int SetDutyCycleForce(const double &c_d_duty, const  int &c_i_m, int i_pwm_no);
	// disables PWM peripheral first,
	//Sets Duty Cycle as a Percentage and PWM mode...
	// then enables PWM peripheral

	unsigned int SetMode(const  int &c_i_m);
	// sets PWM mode...calls 'setDutyCycleForce()'

	void SetDirection(int i_pwm_mod, int i_direction);

	double GetFrequency() const;
	// returns current Frequency of PWM waveform

	double GetDutyCycle() const;
	// returns current DutyCycle (as a %) of PWM waveform

	int GetCounts() const;
	// returns PWM resolution

	int GetDivisor() const;
	//returns Divisor value used to set the period per count
	//as a function of the default PWM clock Frequency of 19.2MHz

	int GetMode() const;
	//returns (1) if current PWM mode is 'PWMMODE' or (2) if current PWM mode
	//is 'MSMODE'

	//Public constants
	static const int PWMMODE = 1;
	static const int MSMODE = 2;
	//Two PWM modes
	static const int ERRFREQ = 1;
	static const int ERRCOUNT = 2;
	static const int ERRDUTY = 3;
	static const int ERRMODE = 4;
	//Error Codes

private:
	//Private constants
	static const int BCM2708_PERI_BASE = 0x3F000000;//0x20000000;
	static const int PWM_BASE = (BCM2708_PERI_BASE + 0x20C000); /* PWM controller */
	static const int CLOCK_BASE = (BCM2708_PERI_BASE + 0x101000); /* Clock controller */
	static const int GPIO_BASE = (BCM2708_PERI_BASE + 0x200000); /* GPIO controller */
	//Base register addresses
	static const int PWM_CTL = 0;
	static const int PWM_RNG1 = 4;
	static const int PWM_DAT1 = 5;
	static const int PWM_RNG2 = 8;
	static const int PWM_DAT2 = 9;
	static const int PWMCLK_CNTL= 40;
	static const int PWMCLK_DIV = 41;

	// Register addresses offsets divided by 4 (register addresses are word (32-bit) aligned
	static const int BLOCK_SIZE = 4096;
	// Block size.....every time mmap() is called a 4KB
	//section of real physical memory is mapped into the memory of
	//the process


	volatile unsigned *MapRegisterAddres(unsigned long u_l_base_address);
	// this function is used to map physical memory

	void ConfigPWMPin();
	//this function sets GPIO18 to the alternat function 5 (ALT5)
	// to enable the pin to output the PWM waveforms generated by PWM1

	void ConfigPWM();
	//This function is responsible for the global configuration and initialixation
	//of the the PWM1 peripheral

	double d_frequency; // PWM frequency
	double d_dutyCycle; //PWM duty Cycle (%)
	unsigned int u_i_counts; // PWM resolution
	unsigned int u_i_divisor; // divisor value
	int i_mode;  // PWM mode
	int i_direction0, i_dirLast0, i_direction1, i_dirLast1;
	volatile unsigned *p_v_u_clk, *p_v_u_pwm, *p_v_u_gpio; // pointers to the memory mapped sections
	//of our process memory

};



#endif /* INCLUDE_IMPWM_H_ */
